#!/usr/bin/python2

import os
import sys
import string

from connect_lib.histogram import show_histogram
from connect_lib.project import update_project
from connect_lib.status import get_status
from connect_lib.watch import watch

try:
    from StringIO import StringIO
except ImportError:
    from io import StringIO

try:
    import ConfigParser
except ImportError:
    import configparser as ConfigParser


class ConnectException(Exception):
    pass


DefaultConfig = '''
[connect]
blacklist = /etc/ciconnect/project_blacklist
client = false
'''


class ConnectConfig(ConfigParser.SafeConfigParser):
    cleantrans = ['_'] * 256
    for c in string.ascii_letters + string.digits:
        cleantrans[ord(c)] = c
    cleantrans = ''.join(cleantrans)

    def _clean(self, s):
        return s.translate(self.cleantrans)

    def toEnv(self):
        for section in self.sections():
            for option in self.options(section):
                key = self._clean(section) + '_' + self._clean(option)
                yield ((key, self.get(section, option)))

    def toShell(self):
        yield '''q="'" '''
        yield '''qq='"' '''
        for key, val in self.toEnv():
            val = val.replace('\\', '\\\\').replace("'", "${q}")
            yield "%s=\"%s\"" % (key, val)
            yield ('export ' + key)

    def include(self, section, recurse=True):
        while self.has_section('include'):
            found = False
            for option in self.options('include'):
                # if it's really from [DEFAULT], ignore
                value = self.get('include', option)
                try:
                    if self.get('DEFAULT', option) == value:
                        continue
                except ConfigParser.NoOptionError:
                    pass
                found = True
                self.remove_option('include', option)
                self.read(value)
            if not found:
                break
            if not recurse:
                break


def main():
    """
    Tsting
    :return:
    """
    parser = argparse.ArgumentParser(description="Connect related commands",
                                     usage=usage_text)
    # General arguments
    parser.add_argument('--version', action='version',
                        version='%(prog)s ' + VERSION)
    parser.add_argument('--user', dest='user', default=None,
                        help='Username to use to login')
    parser.add_argument('--test', dest='test', action='store_true',
                        help=argparse.SUPPRESS)

    subparsers = parser.add_subparsers(title='subcommands',
                                       description='valid actions that can be taken',
                                       help="Command for connect command")
    # create subparser for list action
    histogram_parser = subparsers.add_parser('histogram',
                                        help='Show sites where jobs are running')
    histogram_parser.set_defaults(func=show_histogram)

    # create subparser for status action
    status_parser = subparsers.add_parser('status',
                                          help='Get status ')
    status_parser.add_argument('--user', dest='user', default=None,
                               help='Username to use to login')
    status_parser.set_defaults(func=get_status)

    # create subparser for remove action
    project_parser = subparsers.add_parser('project',
                                          help='Set project for job submissions')
    project_parser.set_defaults(func=update_project)

    # create subparser for retry action
    watch_parser = subparsers.add_parser('watch',
                                         help='Watch jobs')
    watch_parser.set_defaults(func=watch)

    args = parser.parse_args(sys.argv[1:])

    config = ConnectConfig(defaults)
    fp = StringIO.StringIO(DefaultConfig)
    config.read_file(fp)
    fp.close()

    # Read all possible configuration files
    for path in configs:
        config.read(os.path.expanduser(path))

    # Search for config inclusions, recursively
    config.include('include', recurse=True)

    args.func(args)


if __name__ == '__main__':
    try:
        main = Main()
        sys.exit(main(sys.argv[1:]))
    except KeyboardInterrupt:
        sys.stderr.write("\ninterrupt\n")
